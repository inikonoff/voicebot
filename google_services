# google_services.py
import os
import io
import logging
import asyncio
import google.generativeai as genai
import speech_recognition as sr
from pydub import AudioSegment

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --- КОНСТАНТЫ ---
# Ключ Gemini (берем из переменных окружения или используем твой по умолчанию)
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "AIzaSyAItxTpB4VkgfqJewRrKt9oJRoVz0o87OM")

# Настройка Gemini
genai.configure(api_key=GEMINI_API_KEY)

# Настройка модели (используем flash для скорости и бесплатности)
model = genai.GenerativeModel('gemini-1.5-flash')

# --- ФУНКЦИИ ---

def convert_ogg_to_wav(ogg_bytes: bytes) -> io.BytesIO:
    """Конвертирует OGG (Telegram) в WAV (Google STT) с помощью FFmpeg/Pydub"""
    try:
        audio = AudioSegment.from_ogg(io.BytesIO(ogg_bytes))
        wav_io = io.BytesIO()
        audio.export(wav_io, format="wav")
        wav_io.seek(0)
        return wav_io
    except Exception as e:
        logger.error(f"Ошибка конвертации аудио: {e}")
        raise e

def recognize_google_sync(wav_io: io.BytesIO, language="ru-RU") -> str:
    """Синхронная функция распознавания через Google Web Speech API"""
    recognizer = sr.Recognizer()
    with sr.AudioFile(wav_io) as source:
        audio_data = recognizer.record(source) # Читаем весь файл
        try:
            # Используем публичный API Google (бесплатный)
            text = recognizer.recognize_google(audio_data, language=language)
            return text
        except sr.UnknownValueError:
            return "" # Речь не распознана
        except sr.RequestError as e:
            return f"Ошибка сервиса Google: {e}"

async def transcribe_voice_google(audio_bytes: bytes) -> str:
    """Асинхронная обертка для распознавания голоса"""
    try:
        # 1. Конвертация (в отдельном потоке, чтобы не блокировать бота)
        wav_io = await asyncio.to_thread(convert_ogg_to_wav, audio_bytes)
        
        # 2. Распознавание (в отдельном потоке)
        text = await asyncio.to_thread(recognize_google_sync, wav_io)
        
        if not text:
            return "Не удалось разобрать речь (тишина или неразборчиво)."
        return text
    except Exception as e:
        return f"Ошибка при обработке голоса: {e}"

async def correct_text_with_gemini(raw_text: str) -> str:
    """Коррекция текста через Google Gemini"""
    
    prompt = (
        "Ты — профессиональный редактор и корректор. Твоя задача отредактировать текст пользователя.\n"
        "Правила:\n"
        "1. Исправь все орфографические, пунктуационные и грамматические ошибки.\n"
        "2. Разбей текст на логические предложения. Обязательно ставь точки и заглавные буквы.\n"
        "3. Удали мусорные слова (э-э, ну, типа, короче), если они не несут смысла.\n"
        "4. Смягчи грубые выражения, если они есть, до литературных аналогов.\n"
        "5. Верни ТОЛЬКО исправленный текст без кавычек, без вступлений типа 'Вот исправленный текст'.\n\n"
        f"Текст для обработки:\n{raw_text}"
    )

    try:
        response = await model.generate_content_async(prompt)
        return response.text.strip()
    except Exception as e:
        logger.error(f"Gemini Error: {e}")
        return f"Ошибка нейросети: {e}"

async def explain_correction_gemini(raw_text: str, corrected_text: str, user_question: str) -> str:
    """Объяснение правок через Gemini"""
    prompt = (
        "Ты — учитель русского языка. Пользователь хочет узнать, почему ты исправил текст именно так.\n"
        f"Исходный текст: {raw_text}\n"
        f"Исправленный текст: {corrected_text}\n"
        f"Вопрос пользователя: {user_question}\n\n"
        "Объясни кратко и понятно правило."
    )
    
    try:
        response = await model.generate_content_async(prompt)
        return response.text.strip()
    except Exception as e:
        return f"Не удалось получить объяснение: {e}"